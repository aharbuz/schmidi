---
phase: 05-instrument-personality
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - src/renderer/audio/SlideEngine.ts
  - src/renderer/audio/SlideTrack.ts
autonomous: true
requirements: [SLIDE-07, SLIDE-08, SLIDE-09]

must_haves:
  truths:
    - "Hold mode keeps tracks at arrived pitch until chord is released (existing behavior, but now explicitly gated by postArrivalMode)"
    - "Cycle mode makes tracks depart and reconverge to same chord targets in a breathing/pulsing pattern"
    - "Silent idle mode sets idleVolume to 0 and exposes silentMode flag on track state for visualization"
    - "Quiet sliding idle mode uses current idle volume (preset-dependent)"
    - "Ambient drone creates 2-3 detuned oscillators on root+fifth that fade out on chord press and fade back in on release"
    - "Scale-snapped idle motion passes frequencies through magnetic snap quantizer"
    - "Scale-snapped convergence uses staircase curve (setValueCurveAtTime with stepped Float32Array) instead of smooth ramp"
    - "Scale frequency table rebuilds on key change, mode change, or snap scale change"
  artifacts:
    - path: "src/renderer/audio/SlideEngine.ts"
      provides: "Cycle mode logic, idle mode branching, DroneLayer, scale table integration, setScaleFrequencies method"
      contains: "DroneLayer"
    - path: "src/renderer/audio/SlideTrack.ts"
      provides: "Scale-snapped frequency ramps, staircase convergence, idleMode-aware scheduling"
      contains: "buildStaircaseCurve"
  key_links:
    - from: "src/renderer/audio/SlideEngine.ts"
      to: "src/renderer/music/scaleFrequencies.ts"
      via: "buildScaleFrequencyTable for scale table, magneticSnap for idle motion"
      pattern: "buildScaleFrequencyTable"
    - from: "src/renderer/audio/SlideTrack.ts"
      to: "src/renderer/music/scaleFrequencies.ts"
      via: "buildStaircaseCurve for stepped convergence ramps"
      pattern: "buildStaircaseCurve"
    - from: "src/renderer/audio/SlideEngine.ts"
      to: "src/renderer/audio/presets.ts"
      via: "IdleMode and PostArrivalMode types for mode branching"
      pattern: "IdleMode"
---

<objective>
Implement the three new engine behaviors: cycle mode (Hold vs Cycle post-arrival), idle mode branching (Silent, Quiet Sliding, Ambient Drone), and scale-snapped glissando (magnetic snap + staircase convergence).

Purpose: These are the audio engine changes that make the personality presets audible. Plan 01 created the preset definitions and scale utilities; this plan wires them into the SlideEngine and SlideTrack state machines so the behaviors actually happen.

Output: Modified `SlideEngine.ts` with cycle mode, idle mode logic, DroneLayer, and scale table integration. Modified `SlideTrack.ts` with scale-snapped frequency ramps and staircase convergence.
</objective>

<execution_context>
@/Users/aharbuz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aharbuz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-instrument-personality/05-CONTEXT.md
@.planning/phases/05-instrument-personality/05-RESEARCH.md
@.planning/phases/05-instrument-personality/05-01-SUMMARY.md
@src/renderer/audio/SlideEngine.ts (1063 lines -- the main file to modify)
@src/renderer/audio/SlideTrack.ts (444 lines -- frequency ramp scheduling to modify)
@src/renderer/audio/presets.ts (created in Plan 01 -- types and preset definitions)
@src/renderer/music/scaleFrequencies.ts (created in Plan 01 -- scale utilities)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement cycle mode, idle modes, and drone layer in SlideEngine</name>
  <files>
    src/renderer/audio/SlideEngine.ts
  </files>
  <action>
Modify SlideEngine to support the three new behaviors. Import `IdleMode, PostArrivalMode` from presets.ts. Import `buildScaleFrequencyTable, magneticSnap` from scaleFrequencies.ts.

**Add state to SlideEngine class:**
- `private idleMode: IdleMode = 'quiet-sliding'`
- `private postArrivalMode: PostArrivalMode = 'hold'`
- `private scaleFreqs: number[] = []` (precomputed scale frequency table)
- `private droneLayer: DroneLayer | null = null`
- `private activeChordFreqs: number[] | null = null` (track active chord for cycle reconvergence -- may already partially exist as convergence targets)

**Add `DroneLayer` inner class** (or top-level class in same file):
- Constructor takes `(ctx: AudioContext, masterGain: GainNode, rootFreq: number)`
- Creates `droneGain` GainNode at gain 0, connected to masterGain
- Creates 3 oscillators: type 'sine', detunes [0, 7, -5] cents, all at rootFreq
- All oscillators connect to droneGain, all started immediately
- `fadeIn(targetVolume: number, duration: number = 0.5)`: anti-click ramp gain up (cancel -> anchor -> ramp)
- `fadeOut(duration: number = 0.3)`: anti-click ramp gain to 0
- `setRootFreq(freq: number)`: update all oscillator frequencies (for key changes)
- `dispose()`: stop all oscillators, disconnect all nodes
- Keep persistent (like SlideTrack oscillators) -- lifecycle managed by idle mode switching

**Add public methods:**

`setIdleMode(mode: IdleMode): void`
- Store `this.idleMode = mode`
- If switching TO 'ambient-drone': create DroneLayer if not exists, fadeIn to `this.config.idleVolume * 0.5` (drone is subtle backdrop)
- If switching FROM 'ambient-drone': fadeOut and dispose DroneLayer
- If switching TO 'silent': set all track swellGain to 0 (they keep moving but silent). Mark a `silentMode` flag accessible via getTrackStates.
- If switching to 'quiet-sliding': restore normal idle volume behavior

`setPostArrivalMode(mode: PostArrivalMode): void`
- Store `this.postArrivalMode = mode`

`setScaleFrequencies(freqs: number[]): void`
- Store `this.scaleFreqs = freqs`
- Pass to all tracks: `track.setScaleFreqs(freqs)` (tracks need the table for staircase convergence in Task 2)

**Modify `onTrackArrival` (or equivalent hold/departure logic):**
- Currently uses `autoCycle` boolean and fixed `holdDuration`.
- Replace with `postArrivalMode` check:
  - If `postArrivalMode === 'hold'`: existing behavior -- track stays held until chord release. Set `holdDuration: Infinity`.
  - If `postArrivalMode === 'cycle'`: after track arrives and holds for `config.holdDuration` ms, start departure. After departure completes (departureFadeTime * 1000 + 50ms buffer), check if chord is still active. If yes, reconverge to same chord targets. Use the existing state machine: held -> departing -> idle -> converging. Do NOT shortcut states.

**Modify convergence trigger (`convergeTo` or `triggerSlideChord`):**
- When chord is pressed and `idleMode === 'ambient-drone'`: fade drone out (0.3s)
- Store the active chord frequencies for cycle reconvergence reference

**Modify chord release (`releaseSlideChord` or equivalent):**
- On chord release: if `idleMode === 'ambient-drone'` and drone exists, fade drone back in
- Clear activeChordFreqs to stop cycle reconvergence

**Modify idle motion scheduling:**
- When `this.scaleFreqs.length > 0` and `config.pitchMovement === 'scale-snapped'`:
  - Apply `magneticSnap(targetFreq, this.scaleFreqs)` to idle target frequencies before scheduling ramps
- When `idleMode === 'silent'`:
  - Still compute and schedule idle motion (tracks move), but set swellGain to 0
  - The track's `getState()` should expose an `idleMode` or `silentMode` flag so visualization can render dimmed orbs

**Add `silentMode` to SlideTrackState** (or use an engine-level flag):
- Extend `SlideTrackState` (in SlideTrack.ts types) to include `silentMode: boolean`
- In `getTrackStates()`, set `silentMode: this.idleMode === 'silent'` for all tracks

**Cycle mode implementation detail:**
- The cycle reconvergence timeout should be stored per-track and cleared on chord release
- Use `track.holdTimeout` (if the pattern exists) or a new `Map<number, NodeJS.Timeout>` for per-track cycle timers
- On chord release, clear ALL cycle timers to prevent orphaned reconvergences

**Drone pitch on key change:**
- If drone exists and `setRootFreq` is called (from existing key change handler), update drone frequencies too
  </action>
  <verify>
Run `npx tsc --noEmit` -- SlideEngine.ts must compile cleanly. Check that DroneLayer class exists and has fadeIn/fadeOut/dispose methods. Check that postArrivalMode branching exists in the arrival handler. Check that scaleFreqs integration exists in idle motion scheduling.
  </verify>
  <done>
SlideEngine supports postArrivalMode 'hold' and 'cycle' with proper state machine transitions. Idle mode branching handles 'silent' (gain 0 + visual flag), 'quiet-sliding' (existing behavior), and 'ambient-drone' (DroneLayer with detuned oscillators). Magnetic snap applied to idle targets when scale-snapped. Drone fades out on chord press, fades back in on release. All cycle timers cleared on chord release.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement scale-snapped convergence in SlideTrack</name>
  <files>
    src/renderer/audio/SlideTrack.ts
  </files>
  <action>
Modify SlideTrack to support scale-snapped convergence ramps and expose scale frequency data.

**Add state:**
- `private scaleFreqs: number[] = []`
- `public silentMode: boolean = false` (set by engine, read by getState)

**Add methods:**
- `setScaleFreqs(freqs: number[]): void` -- store the frequency table
- `setSilentMode(silent: boolean): void` -- set silentMode flag

**Extend `SlideTrackState` interface:**
- Add `silentMode: boolean` field
- In `getState()`, include `silentMode: this.silentMode`

**Modify frequency ramp scheduling for convergence:**
The existing convergence code schedules frequency ramps (linear, ease-in, ease-out, ease-in-out) via setValueCurveAtTime or linearRampToValueAtTime.

When `config.pitchMovement === 'scale-snapped'` AND `this.scaleFreqs.length > 0` AND the track is in converging state:
- Import `buildStaircaseCurve` from `scaleFrequencies.ts`
- Instead of the normal smooth ramp, call `buildStaircaseCurve(currentFreq, targetFreq, this.scaleFreqs, 512)`
- Use `frequency.setValueCurveAtTime(staircaseCurve, startTime, duration)` to schedule the stepped convergence
- This creates the "harp-like cascading approach" the user wants

When `config.pitchMovement === 'scale-snapped'` for idle motion:
- Apply magnetic snap to idle motion targets before scheduling (this is done in SlideEngine Task 1 for idle target computation, but if SlideTrack also schedules idle motion internally, apply magneticSnap here too)

**Important: do NOT change non-scale-snapped behavior.**
The existing easing curves (linear, ease-in, ease-out, ease-in-out) must continue to work exactly as before when pitchMovement is 'continuous'. Only add the scale-snap path as an alternative branch.

**Anti-click:** The staircase curve values are frequency steps. The setValueCurveAtTime call handles the scheduling atomically -- no additional anti-click needed for frequency (only gain changes need anti-click). But verify that the existing cancelScheduledValues + setValueCurveAtTime pattern is preserved for interrupt-retarget behavior.
  </action>
  <verify>
Run `npx tsc --noEmit` -- SlideTrack.ts must compile cleanly. Verify that `buildStaircaseCurve` is imported and used in the convergence path. Verify that `SlideTrackState` now includes `silentMode`. Verify that `setScaleFreqs` method exists.
  </verify>
  <done>
SlideTrack supports scale-snapped convergence via staircase curves. When pitchMovement is 'scale-snapped' and scaleFreqs are available, convergence uses buildStaircaseCurve instead of smooth ramps. SlideTrackState includes silentMode boolean. Continuous pitch movement behavior is unchanged. All compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx eslint src/renderer/audio/SlideEngine.ts src/renderer/audio/SlideTrack.ts --max-warnings=0` passes
3. DroneLayer class has constructor, fadeIn, fadeOut, setRootFreq, dispose methods
4. postArrivalMode branching exists in arrival handler (grep for 'cycle' in the arrival method)
5. magneticSnap is called in idle motion scheduling when scale-snapped
6. buildStaircaseCurve is called in convergence when pitchMovement === 'scale-snapped'
7. SlideTrackState type includes silentMode field
</verification>

<success_criteria>
- Cycle mode: tracks depart and reconverge when postArrivalMode is 'cycle', stopped cleanly on chord release
- Silent mode: tracks move but produce no sound, silentMode flag exposed for visualization
- Ambient drone: detuned oscillators on root+fifth, fades out on chord press, fades back in on release
- Scale-snapped idle: magnetic snap applied to idle target frequencies
- Scale-snapped convergence: staircase curves through scale degrees instead of smooth ramps
- Scale table rebuilds when setScaleFrequencies is called
- All existing continuous-mode behavior unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-instrument-personality/05-02-SUMMARY.md`
</output>
