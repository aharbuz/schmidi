---
phase: 03-convergence-engine-slide-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/audio/SlideTrack.ts
  - src/renderer/audio/SlideEngine.ts
autonomous: true
requirements:
  - SLIDE-02
  - SLIDE-03
  - SLIDE-04

must_haves:
  truths:
    - "SlideTrack wraps a persistent oscillator + dual gain chain (swell + track volume) that can glide continuously via AudioParam ramps"
    - "SlideEngine manages N SlideTrack instances with a setTimeout-based lookahead scheduler driving continuous idle motion"
    - "Convergence assigns tracks to nearest chord notes (distance-optimized) and schedules simultaneous-arrival ramps"
    - "Proximity-based gain automation swells track volume as pitch approaches target and fades on departure"
    - "Track state machine (idle -> converging -> held -> departing) handles full lifecycle including hold timeout and departure"
    - "Model A (heat-seeker) and Model C (spawn-overflow) are both implemented and toggleable"
    - "Track count is dynamically changeable via setTrackCount without audio glitches"
  artifacts:
    - path: "src/renderer/audio/SlideTrack.ts"
      provides: "Single sliding voice with persistent oscillator, swell gain, track gain, LFO micro-motion, frequency/gain ramp scheduling"
      min_lines: 80
    - path: "src/renderer/audio/SlideEngine.ts"
      provides: "N-track slide engine with idle scheduler, convergence, note assignment, proximity gain, hold/departure, Model A + C"
      min_lines: 300
  key_links:
    - from: "src/renderer/audio/SlideTrack.ts"
      to: "AudioContext + masterGain"
      via: "constructor wiring: osc -> swellGain -> trackGain -> masterGain"
      pattern: "osc\\.connect.*swellGain.*connect.*trackGain.*connect.*masterGain"
    - from: "src/renderer/audio/SlideEngine.ts"
      to: "src/renderer/audio/SlideTrack.ts"
      via: "creates and manages SlideTrack instances"
      pattern: "new SlideTrack"
---

<objective>
Build the core audio engine for slide mode: SlideTrack (single sliding voice) and SlideEngine (N-track manager with idle motion, convergence, proximity gain, hold/departure, and both Model A and Model C).

Purpose: This is the load-bearing audio foundation for Phase 3. All subsequent plans (store wiring, UI controls) depend on this engine existing and being functionally complete. The engine must handle all audio-level behavior: continuous pitch gliding, simultaneous convergence on chord targets, proximity-based volume swelling, and the full track lifecycle.

Output: Two new files — `SlideTrack.ts` and `SlideEngine.ts` — containing the complete slide mode audio engine.
</objective>

<execution_context>
@/Users/aharbuz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aharbuz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-convergence-engine-slide-mode/03-CONTEXT.md
@.planning/phases/03-convergence-engine-slide-mode/03-RESEARCH.md
@src/renderer/audio/Voice.ts
@src/renderer/audio/ChordVoiceManager.ts
@src/renderer/audio/masterBus.ts
@src/renderer/audio/constants.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SlideTrack — persistent sliding voice with dual gain chain and LFO</name>
  <files>src/renderer/audio/SlideTrack.ts</files>
  <action>
Create `SlideTrack` class — the audio primitive for a single sliding voice. Follow the persistent oscillator pattern from Voice.ts but with a dual gain chain for proximity swell + per-track volume.

**Audio graph:** `OscillatorNode -> swellGain (proximity-driven 0-1) -> trackGain (per-track volume slider) -> masterGain`

**Constructor:** Takes `AudioContext`, `masterGain: GainNode`, `startFreq: number`, `waveformType: WaveformType`. Creates oscillator at `startFreq`, swellGain at floor volume (0.1), trackGain at 0.7. Starts oscillator immediately (persistent, never stopped). Stores `currentFreq` as JS-side logical frequency.

**State:** Track state enum `'idle' | 'converging' | 'held' | 'departing'`. Default: `'idle'`. Also store: `targetFreq: number | null`, `initialDistance: number` (semitone distance at convergence start, for proximity calculation), `convergenceStartTime: number`, `convergenceDuration: number`, `holdTimeout: ReturnType<typeof setTimeout> | null`.

**Methods:**
- `scheduleFrequencyRamp(targetHz, durationSeconds, easing: 'linear' | 'ease-in' | 'ease-out')`: Anti-click cancel->anchor->ramp on osc.frequency. For linear: `linearRampToValueAtTime`. For ease-in/ease-out: use `setValueCurveAtTime` with computed Float32Array curve (256 samples). Clamp target to >= 1 Hz. Update `targetFreq`, `convergenceStartTime`, `convergenceDuration`.
- `scheduleGainRamp(targetGain, durationSeconds)`: Anti-click cancel->anchor->ramp on swellGain.gain.
- `setTrackVolume(volume)`: Anti-click 20ms ramp on trackGain.gain (matches ChordVoiceManager.setDegreeVolume pattern).
- `setWaveform(type: WaveformType)`: Set osc.type.
- `getLogicalFreq(now: number)`: Compute current logical frequency using linear interpolation between startFreq and targetFreq based on elapsed time vs convergenceDuration. When state is 'idle' or 'held', return currentFreq. When converging, interpolate. This is used for proximity calculation — do NOT read osc.frequency.value.
- `updateLogicalFreq(now: number)`: Call getLogicalFreq and store result in `currentFreq`. Called by engine scheduler each tick.
- `cancelAllRamps()`: Cancel scheduled values on both osc.frequency and swellGain.gain, anchor current values. Used for mode switch cleanup.

**LFO micro-motion (vibrato when held):**
- `enableMicroMotion(depthCents: number, rateHz: number)`: Create lfoOsc (sine, rateHz) -> lfoGain (depthCents) -> osc.detune. Start lfoOsc.
- `disableMicroMotion()`: Stop and disconnect LFO nodes. Set to null.
- Store `lfoOsc: OscillatorNode | null` and `lfoGain: GainNode | null`.

**Dispose:** Stop oscillator, disconnect all nodes (osc, swellGain, trackGain, lfo nodes if any). Matches Voice.dispose() pattern.

**Export** a `SlideTrackState` type for UI state reporting: `{ state: SlideTrackState['state'], currentFreq: number, targetFreq: number | null, proximity: number }`.

Also export configuration types needed by SlideEngine:
```typescript
export type EasingType = 'linear' | 'ease-in' | 'ease-out';
export type TrackModel = 'heat-seeker' | 'spawn-overflow';
export type IdleMovementMode = 'stationary' | 'slow-drift' | 'always-moving';
export type IdleRangeType = 'free-roam' | 'orbit-home' | 'stay-in-scale';
export type StartingPosition = 'root-note' | 'random' | 'last-known';
export type TrackCorrelation = 'independent' | 'loosely-correlated' | 'unison';
export type PitchBoundary = 'musical-window' | 'key-octave' | 'unconstrained';
export type EdgeBehavior = 'reflect' | 'wrap-around' | 'smooth-curve';
export type SwellCurve = 'linear' | 'exponential';
export type DepartureDirection = 'random' | 'inverse' | 'continue';
export type ModeToggleBehavior = 'resume' | 'reset-home';
export type TrackPartitioning = 'independent' | 'partition-range';
export type TrackInteraction = 'none' | 'avoid-clustering';
export type MidConvergenceBehavior = 'interrupt-retarget' | 'finish-then-retarget' | 'spawn-overflow';

export interface SlideConfig {
  // Track model
  trackModel: TrackModel;
  trackCount: number;

  // Convergence
  convergenceDuration: number; // seconds (0 = instant)
  convergenceEasing: EasingType;
  convergenceMode: 'fixed-time' | 'distance-proportional';
  midConvergenceBehavior: MidConvergenceBehavior;
  durationPerOctave: number; // seconds, for distance-proportional mode
  minDuration: number; // seconds, floor for distance-proportional

  // Idle behavior
  idleMovementMode: IdleMovementMode;
  idleRangeType: IdleRangeType;
  startingPosition: StartingPosition;
  trackCorrelation: TrackCorrelation;
  correlationFactor: number; // 0-1
  pitchBoundary: PitchBoundary;
  edgeBehavior: EdgeBehavior;
  movementSpeed: number; // semitones per second
  movementSpeedVariation: number; // 0-1, organic randomness
  pitchMovement: 'continuous' | 'scale-snapped';
  modeToggleBehavior: ModeToggleBehavior;
  trackPartitioning: TrackPartitioning;
  trackInteraction: TrackInteraction;

  // Volume envelope
  swellCurve: SwellCurve;
  floorVolume: number; // 0-1
  heldVolume: number; // 0-1
  departureFadeTime: number; // seconds
  idleVolume: number; // 0-1

  // Post-arrival
  holdDuration: number; // seconds (Infinity = hold indefinitely)
  departureDirection: DepartureDirection;
  landingBounce: boolean;
  bounceDepthCents: number; // overshoot amount
  bounceDecayTime: number; // seconds
  microMotion: boolean;
  microMotionDepth: number; // cents
  microMotionRate: number; // Hz
  autoCycle: boolean; // restart wandering while held

  // Anchor
  anchorEnabled: boolean;
  anchorFiresOnPress: boolean;

  // Spawn overflow (Model C)
  spawnStartPosition: StartingPosition;
  maxSpawnedTracks: number;
}
```

Define `DEFAULT_SLIDE_CONFIG` with sensible defaults:
- trackModel: 'heat-seeker', trackCount: 2
- convergenceDuration: 1.5, convergenceEasing: 'linear', convergenceMode: 'fixed-time'
- midConvergenceBehavior: 'interrupt-retarget'
- idleMovementMode: 'slow-drift', idleRangeType: 'free-roam', startingPosition: 'root-note'
- trackCorrelation: 'independent', pitchBoundary: 'musical-window'
- edgeBehavior: 'reflect', movementSpeed: 2, movementSpeedVariation: 0.3
- pitchMovement: 'continuous', modeToggleBehavior: 'resume', trackPartitioning: 'independent', trackInteraction: 'none'
- swellCurve: 'linear', floorVolume: 0.1, heldVolume: 0.8, departureFadeTime: 1.0, idleVolume: 0.1
- holdDuration: Infinity, departureDirection: 'random', landingBounce: false, microMotion: false, autoCycle: false
- anchorEnabled: true, anchorFiresOnPress: true
- spawnStartPosition: 'random', maxSpawnedTracks: 16
  </action>
  <verify>
Run `npx tsc --noEmit` from project root — no type errors in SlideTrack.ts. Verify the file exports SlideTrack class, all config types, SlideConfig interface, and DEFAULT_SLIDE_CONFIG.
  </verify>
  <done>
SlideTrack.ts exists with: persistent oscillator + dual gain chain, frequency/gain ramp scheduling with anti-click pattern, easing curve support, logical frequency tracking, LFO micro-motion, all slide config types and defaults exported. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SlideEngine — N-track manager with idle motion, convergence, Model A + C</name>
  <files>src/renderer/audio/SlideEngine.ts</files>
  <action>
Create `SlideEngine` class — the N-track slide engine managing all slide mode audio behavior.

**Constructor:** Takes `AudioContext`, `masterGain: GainNode`, `config: Partial<SlideConfig>` (merged with DEFAULT_SLIDE_CONFIG). Creates `config.trackCount` SlideTrack instances at starting positions (root note of C4 = 261.63 Hz by default). Does NOT start scheduler in constructor — caller must call `startScheduler()`.

**Core state:**
- `tracks: SlideTrack[]` — persistent tracks
- `spawnedTracks: SlideTrack[]` — ephemeral tracks for Model C
- `config: SlideConfig` — full merged config
- `schedulerHandle: ReturnType<typeof setTimeout> | null`
- `activeDegree: number | null` — currently targeted chord degree (monophonic)
- `activeChordFreqs: number[] | null` — target frequencies for current chord
- `isRunning: boolean`
- `rootFreq: number` — root note frequency (C4 default, updated on key change)
- `pitchBoundaryLow: number` — low boundary in Hz (C2 = 65.41 default for 'musical-window')
- `pitchBoundaryHigh: number` — high boundary in Hz (C6 = 1046.5 default)

**Scheduler (setTimeout-based lookahead):**
- `LOOKAHEAD_MS = 100`, `SCHEDULE_INTERVAL_MS = 50`
- `startScheduler()`: Starts the tick loop. Sets `isRunning = true`.
- `pauseScheduler()`: Clears timeout. Cancels all in-flight ramps on all tracks (cancel->anchor->floor volume). Silences tracks. Sets `isRunning = false`.
- `tick()`: Called every 50ms. For each track:
  - Update `logicalFreq` via `track.updateLogicalFreq(now)`
  - If `state === 'idle'`: call `scheduleIdleMotion(track, scheduleUntil)`
  - If `state === 'converging'`: call `updateProximityGain(track)`; check if arrived (distance < 0.5 semitones) and transition to 'held'
  - If `state === 'held'`: no-op (held at target, micro-motion LFO handles vibrato)
  - If `state === 'departing'`: update departure progress; check if departure fade complete -> transition to 'idle'
  - Also tick spawned tracks with same logic, disposing completed ones.

**Idle motion (scheduleIdleMotion):**
Implementation per idleMovementMode:
- `'stationary'`: no-op
- `'slow-drift'` / `'always-moving'`: Pick a random target frequency within bounds. Speed = config.movementSpeed +/- config.movementSpeedVariation * random factor. Schedule a frequency ramp to the target over the computed duration.
- Apply boundary logic: compute next target, check against pitchBoundaryLow/High. If out of bounds, apply edgeBehavior: 'reflect' reverses direction, 'wrap-around' teleports to opposite bound, 'smooth-curve' picks a target back toward center.
- Apply track correlation: if 'loosely-correlated', next target = random * (1 - correlationFactor) + averageOfAllTracks * correlationFactor. If 'unison', all tracks target the same pitch.
- Apply track partitioning: if 'partition-range', divide pitch range evenly among tracks. Track i operates in [low + i*(range/N), low + (i+1)*(range/N)].
- Apply track interaction: if 'avoid-clustering', if another track is within 2 semitones, push target away.
- Set swellGain to idleVolume for idle tracks.
- For 'orbit-home': target oscillates around rootFreq within a configurable orbit radius.

**Convergence (convergeTo):**
- `convergeTo(degree: number, chordFreqs: number[])`:
  1. Set `activeDegree = degree`, `activeChordFreqs = chordFreqs`
  2. If midConvergenceBehavior === 'spawn-overflow' AND trackModel === 'spawn-overflow' AND any track is currently converging: spawn new tracks (Model C path), let existing finish.
  3. Otherwise (Model A / interrupt-retarget): for all persistent tracks, cancel current ramps.
  4. Assign tracks to chord notes via `assignTracksToNotes()` (distance-optimized greedy).
  5. Compute convergence duration:
     - Fixed-time: `config.convergenceDuration` for all
     - Distance-proportional: maxDist determines duration, all arrive at same time
     - If 0: instant arrival (setValueAtTime, no ramp)
  6. For each track: `track.scheduleFrequencyRamp(targetHz, duration, easing)`. Set `track.state = 'converging'`, `track.initialDistance = semitone distance`, `track.targetFreq = targetHz`.
  7. Immediately start anticipatory swell: schedule swellGain ramp from floor toward a midpoint.
- For 'finish-then-retarget': don't cancel current ramps; instead queue the new target. When current convergence completes (arrival detected), apply queued target.

**Note assignment (assignTracksToNotes):**
- Greedy nearest-neighbor: for each track, find the chord note closest in semitone distance. If more tracks than notes, multiple tracks can target the same note.
- Distance in semitones: `Math.abs(Math.log2(f1/f2) * 12)`

**Proximity gain (updateProximityGain):**
- Only for 'converging' state. Compute proximity: `1 - Math.min(1, currentDist / initialDistance)`. Apply swellCurve:
  - linear: `floor + proximity * (held - floor)`
  - exponential: `floor + (proximity ** 2) * (held - floor)`
- Schedule swellGain ramp to computed gain over 50ms lookahead. Use anti-click pattern.

**Arrival detection and hold:**
- In tick, if converging track distance < 0.5 semitones from target: call `onTrackArrival(track)`.
- `onTrackArrival(track)`: Set `track.state = 'held'`, `track.currentFreq = track.targetFreq`. Set swellGain to heldVolume. If `config.microMotion`: `track.enableMicroMotion(config.microMotionDepth, config.microMotionRate)`. If `config.landingBounce`: schedule overshoot on osc.frequency (bounce by bounceDepthCents above target, then setTargetAtTime back with bounceDecayTime). If `holdDuration !== Infinity`: set `track.holdTimeout = setTimeout(() => startDeparture(track), holdDuration * 1000)`.
- If `config.autoCycle && state === 'held'`: after a brief hold, start departure automatically, then resume idle. This makes tracks restart wandering while chord is still held.

**Chord release (releaseChord):**
- `releaseChord()`: For all tracks in 'held' or 'converging' state: clear holdTimeout, call `startDeparture(track)`.
- For spawned tracks: same — start departure.
- Set `activeDegree = null`, `activeChordFreqs = null`.

**Departure (startDeparture):**
- Set `track.state = 'departing'`. Disable micro-motion if active.
- Pick departure target frequency based on config.departureDirection:
  - 'random': random frequency within bounds
  - 'inverse': opposite direction from approach
  - 'continue': same direction as approach (past the target)
- Departure starting point: from arrived note (current position).
- Schedule frequency ramp to departure target over departureFadeTime.
- Schedule swellGain ramp from heldVolume to floorVolume over departureFadeTime.
- Set timeout: after departureFadeTime, set `track.state = 'idle'`.

**Model C (spawn-overflow):**
- When convergeTo is called with spawn-overflow and tracks are mid-convergence:
  1. Create new SlideTrack instances (one per chord note). Starting position per config.spawnStartPosition.
  2. Add to `spawnedTracks` array.
  3. Schedule convergence ramps on spawned tracks (same as normal convergence).
  4. Existing tracks continue their current ramps.
- Spawned track lifecycle: converging -> held -> departing -> dispose.
- On disposal: call `track.dispose()`, remove from spawnedTracks array.
- Safety cap: if `spawnedTracks.length >= config.maxSpawnedTracks`, dispose oldest spawned tracks.

**Dynamic track count (setTrackCount):**
- `setTrackCount(n: number)`: If n > current: add tracks at rootFreq with floor volume, idle state. If n < current: dispose last (n - current) tracks cleanly (cancel ramps, silence, dispose). Update `config.trackCount`.

**Configuration update:**
- `updateConfig(partial: Partial<SlideConfig>)`: Merge into config. Apply relevant changes immediately (e.g., if trackCount changed, call setTrackCount; if idleVolume changed, update idle tracks' swell gain).

**State reporting (for UI):**
- `getTrackStates(): SlideTrackState[]`: Returns array of track states for rendering.

**Cleanup:**
- `dispose()`: Stop scheduler, dispose all tracks and spawned tracks, clear state.

**Key root/boundary updates:**
- `setRootFreq(freq: number)`: Update rootFreq. If startingPosition is 'root-note' and modeToggleBehavior is 'reset-home', reset idle tracks to root.
- `setPitchBoundaries(low: number, high: number)`: Update boundaries.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root — no type errors. Verify SlideEngine.ts exports the SlideEngine class with all public methods: startScheduler, pauseScheduler, convergeTo, releaseChord, setTrackCount, updateConfig, getTrackStates, setRootFreq, dispose.
  </verify>
  <done>
SlideEngine.ts exists with: N-track management, setTimeout-based lookahead scheduler (50ms interval, 100ms lookahead), idle motion with all 11 configurable behaviors, simultaneous-arrival convergence (fixed-time and distance-proportional), greedy nearest-neighbor note assignment, proximity-based gain automation (linear + exponential swell curves), full track lifecycle (idle->converging->held->departing), hold mechanism with timeout, departure with configurable direction, LFO micro-motion when held, landing bounce, Model A (heat-seeker) + Model C (spawn-overflow), dynamic track count, and configuration updates. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. SlideTrack.ts exports: SlideTrack class, all config types, SlideConfig interface, DEFAULT_SLIDE_CONFIG
3. SlideEngine.ts exports: SlideEngine class with full public API
4. Audio graph: osc -> swellGain -> trackGain -> masterGain (verified in constructor)
5. Scheduler uses setTimeout (not rAF) as per research anti-pattern guidance
6. All AudioParam scheduling uses cancel->anchor->ramp anti-click pattern
7. Logical frequency tracking via JS-side state (not AudioParam.value reads)
</verification>

<success_criteria>
The slide mode audio engine compiles and is ready for integration. SlideTrack handles single-voice gliding with proximity gain. SlideEngine manages N tracks with idle motion, convergence to chord targets, and the full track lifecycle. Both Model A and Model C are implemented. No runtime verification yet — that requires store wiring (Plan 02) and UI (Plan 03).
</success_criteria>

<output>
After completion, create `.planning/phases/03-convergence-engine-slide-mode/03-01-SUMMARY.md`
</output>
