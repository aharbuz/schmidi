---
phase: 03-convergence-engine-slide-mode
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/renderer/store/synthStore.ts
  - src/renderer/hooks/useAudioInit.ts
  - src/renderer/hooks/useSlideKeyboard.ts
autonomous: true
requirements:
  - SLIDE-01
  - SLIDE-04
  - SLIDE-05

must_haves:
  truths:
    - "Zustand store contains slideMode boolean, full SlideConfig state, slide actions (toggleSlideMode, triggerSlideChord, releaseSlideChord, updateSlideConfig), and module-level SlideEngine ref"
    - "useAudioInit creates SlideEngine alongside existing VoiceManager and ChordVoiceManager on audio init"
    - "useSlideKeyboard maps A-J keys to chord targeting in slide mode (same keys as synth mode)"
    - "Anchor voice fires ChordVoiceManager.triggerChord when anchorEnabled and chord is pressed in slide mode"
    - "Track count is changeable via store action and propagates to SlideEngine.setTrackCount"
  artifacts:
    - path: "src/renderer/store/synthStore.ts"
      provides: "Slide mode state slice, SlideEngine ref, slide actions"
      contains: "slideMode"
    - path: "src/renderer/hooks/useAudioInit.ts"
      provides: "SlideEngine creation during audio init"
      contains: "SlideEngine"
    - path: "src/renderer/hooks/useSlideKeyboard.ts"
      provides: "Keyboard handler for slide mode chord targeting"
      min_lines: 30
  key_links:
    - from: "src/renderer/store/synthStore.ts"
      to: "src/renderer/audio/SlideEngine.ts"
      via: "module-level slideEngineRef + store actions calling SlideEngine methods"
      pattern: "slideEngineRef"
    - from: "src/renderer/hooks/useAudioInit.ts"
      to: "src/renderer/audio/SlideEngine.ts"
      via: "creates SlideEngine instance, calls setSlideEngine"
      pattern: "new SlideEngine"
    - from: "src/renderer/store/synthStore.ts"
      to: "src/renderer/audio/ChordVoiceManager.ts"
      via: "anchor voice fires triggerChord when anchorEnabled"
      pattern: "anchorEnabled.*triggerChord"
---

<objective>
Wire the SlideEngine into the application: extend the Zustand store with slide mode state and actions, update audio initialization to create the SlideEngine, create the slide mode keyboard handler, and integrate anchor voice support.

Purpose: Bridges the audio engine (Plan 01) to the React UI layer (Plan 03). Without this wiring layer, the SlideEngine is just a standalone class with no way to control it from the application.

Output: Extended synthStore.ts, updated useAudioInit.ts, new useSlideKeyboard.ts.
</objective>

<execution_context>
@/Users/aharbuz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aharbuz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-convergence-engine-slide-mode/03-CONTEXT.md
@.planning/phases/03-convergence-engine-slide-mode/03-RESEARCH.md
@.planning/phases/03-convergence-engine-slide-mode/03-01-SUMMARY.md
@src/renderer/store/synthStore.ts
@src/renderer/hooks/useAudioInit.ts
@src/renderer/hooks/useChordKeyboard.ts
@src/renderer/audio/SlideEngine.ts
@src/renderer/audio/SlideTrack.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Zustand store with slide mode state, actions, and SlideEngine ref</name>
  <files>src/renderer/store/synthStore.ts</files>
  <action>
Extend the existing `synthStore.ts` with slide mode state and actions. Follow the established pattern of module-level engine refs and Zustand get() for actions that need current state.

**Module-level SlideEngine ref (same pattern as voiceManagerRef and chordVoiceManagerRef):**
```typescript
let slideEngineRef: SlideEngine | null = null;
export function setSlideEngine(se: SlideEngine): void { slideEngineRef = se; }
export function getSlideEngine(): SlideEngine | null { return slideEngineRef; }
```

**Add to SynthState interface — new slide mode state:**
```typescript
// Slide mode state (Phase 3)
slideMode: boolean;
slideConfig: SlideConfig;
activeSlideDegree: number | null;
slideTrackStates: SlideTrackState[];
```

**Add to SynthState interface — new slide mode actions:**
```typescript
// Actions (Phase 3 - Slide mode)
toggleSlideMode: () => void;
triggerSlideChord: (degree: number) => void;
releaseSlideChord: () => void;
updateSlideConfig: (partial: Partial<SlideConfig>) => void;
setSlideTrackCount: (n: number) => void;
updateSlideTrackStates: (states: SlideTrackState[]) => void;
```

**Initial state values:**
- `slideMode: false`
- `slideConfig: { ...DEFAULT_SLIDE_CONFIG }` (import from SlideTrack.ts)
- `activeSlideDegree: null`
- `slideTrackStates: []`

**Action implementations:**

`toggleSlideMode`: Toggle slideMode boolean. When entering slide mode: call `slideEngineRef?.startScheduler()`. When leaving: call `slideEngineRef?.pauseScheduler()`. Use `get()` for current state.

`triggerSlideChord(degree)`: Monophonic — one chord target at a time. Get chordGrid from state. Extract frequencies from `chordGrid[degree - 1]`. Call `slideEngineRef?.convergeTo(degree, frequencies)`. If `get().slideConfig.anchorEnabled && get().slideConfig.anchorFiresOnPress`: also call `chordVoiceManagerRef?.triggerChord(degree, frequencies, get().currentWaveform, get().adsr)`. Set `activeSlideDegree: degree`. If there was a previous active degree, release it first (releaseSlideChord before triggering new).

`releaseSlideChord()`: Call `slideEngineRef?.releaseChord()`. If anchor was playing for `activeSlideDegree`: `chordVoiceManagerRef?.releaseByDegree(activeSlideDegree)`. Set `activeSlideDegree: null`.

`updateSlideConfig(partial)`: Merge into slideConfig. Call `slideEngineRef?.updateConfig(partial)`. If `partial.trackCount !== undefined`: also update slideTrackStates array length. Set new slideConfig in store.

`setSlideTrackCount(n)`: Convenience wrapper — calls `updateSlideConfig({ trackCount: n })`.

`updateSlideTrackStates(states)`: Simple setter, called from animation loop to push track state to UI.

**Also update existing setKey and setMode actions:** When key changes, also call `slideEngineRef?.setRootFreq(newRootFreq)` where newRootFreq is computed from the new key (use `noteFrequency` from music/noteFrequency.ts to get the frequency of the key's root at octave 4). Import `getNoteFrequency` or equivalent.

**Imports to add:** Import `SlideEngine` type, `SlideConfig`, `SlideTrackState`, `DEFAULT_SLIDE_CONFIG` from `../audio/SlideTrack`. Import `setSlideEngine` for the module-level ref.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Verify synthStore.ts contains: slideMode state, slideConfig state, all 6 new actions, slideEngineRef getter/setter.
  </verify>
  <done>
synthStore.ts has: slideMode boolean, full SlideConfig in state, activeSlideDegree, slideTrackStates, and actions for toggleSlideMode, triggerSlideChord, releaseSlideChord, updateSlideConfig, setSlideTrackCount, updateSlideTrackStates. Module-level slideEngineRef with getter/setter. Anchor voice integration in triggerSlideChord. Key/mode changes propagate root frequency to SlideEngine.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update audio init + create slide keyboard hook</name>
  <files>
    src/renderer/hooks/useAudioInit.ts
    src/renderer/hooks/useSlideKeyboard.ts
  </files>
  <action>
**useAudioInit.ts update:**
After creating ChordVoiceManager, create the SlideEngine instance and register it.

Add import: `import { SlideEngine } from '../audio/SlideEngine';` and `import { setSlideEngine } from '../store/synthStore';` and `import { DEFAULT_SLIDE_CONFIG } from '../audio/SlideTrack';`

After `setChordVoiceManager(cvm)`, add:
```typescript
// Create SlideEngine -- connects to the SAME masterGain for unified volume control
// Scheduler not started until user toggles to slide mode
const se = new SlideEngine(ctx, vm.getMasterBus().masterGain, DEFAULT_SLIDE_CONFIG);
setSlideEngine(se);
```

The SlideEngine scheduler is NOT started here — it starts when the user toggles to slide mode (via toggleSlideMode action).

**useSlideKeyboard.ts (new file):**
Create keyboard hook for slide mode chord targeting. Same key mapping as useChordKeyboard (A S D F G H J = degrees 1-7) but routes to slide mode actions.

Pattern: Follow useChordKeyboard.ts exactly — `useRef<Set<string>>` for held keys, global keydown/keyup listeners, repeat guard.

```typescript
import { useEffect, useRef } from 'react';
import { useSynthStore } from '../store/synthStore';

const SLIDE_CHORD_KEYS = ['a', 's', 'd', 'f', 'g', 'h', 'j'];

export function useSlideKeyboard(): void {
  const slideMode = useSynthStore((s) => s.slideMode);
  const triggerSlideChord = useSynthStore((s) => s.triggerSlideChord);
  const releaseSlideChord = useSynthStore((s) => s.releaseSlideChord);
  const heldKeysRef = useRef<Set<string>>(new Set());

  useEffect(() => {
    if (!slideMode) return; // Only active in slide mode

    const handleKeyDown = (e: KeyboardEvent) => {
      const key = e.key.toLowerCase();
      if (e.repeat) return; // Prevent key repeat
      if (!SLIDE_CHORD_KEYS.includes(key)) return;
      if (heldKeysRef.current.has(key)) return; // Already held

      heldKeysRef.current.add(key);
      const degree = SLIDE_CHORD_KEYS.indexOf(key) + 1;

      // Monophonic: release previous chord, trigger new one
      // (triggerSlideChord handles this internally)
      triggerSlideChord(degree);
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      const key = e.key.toLowerCase();
      if (!SLIDE_CHORD_KEYS.includes(key)) return;

      heldKeysRef.current.delete(key);

      // Only release if no keys are held (monophonic — last key up releases)
      if (heldKeysRef.current.size === 0) {
        releaseSlideChord();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      heldKeysRef.current.clear();
    };
  }, [slideMode, triggerSlideChord, releaseSlideChord]);
}
```

Key differences from useChordKeyboard:
1. Only active when `slideMode === true` (effect re-runs on slideMode change)
2. Monophonic: only one chord target at a time (per locked decision)
3. Release fires only when ALL keys are released (last-key-up behavior)
4. Routes to triggerSlideChord / releaseSlideChord instead of Phase 2 actions
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Verify useAudioInit.ts creates SlideEngine. Verify useSlideKeyboard.ts exports the hook with slideMode-gated listeners.
  </verify>
  <done>
useAudioInit.ts creates SlideEngine alongside VoiceManager and ChordVoiceManager (all three sharing the same masterGain). useSlideKeyboard.ts provides monophonic keyboard chord targeting for slide mode with A-J key mapping, repeat prevention, and last-key-up release behavior. All three files compile cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. synthStore.ts has slideMode, slideConfig, 6 new actions, slideEngineRef
3. useAudioInit.ts creates all three audio managers (VoiceManager, ChordVoiceManager, SlideEngine)
4. useSlideKeyboard.ts active only when slideMode is true
5. Anchor integration: triggerSlideChord fires ChordVoiceManager when anchorEnabled
6. Key/mode changes propagate to SlideEngine.setRootFreq
</verification>

<success_criteria>
The SlideEngine is wired into the application via Zustand store and audio init. Keyboard chord targeting works for slide mode. The anchor voice is integrated. All that remains is the UI (Plan 03) and verification (Plan 04).
</success_criteria>

<output>
After completion, create `.planning/phases/03-convergence-engine-slide-mode/03-02-SUMMARY.md`
</output>
