---
phase: 01-audio-foundation
plan: 02
type: tdd
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/shared/types.ts
  - src/renderer/audio/audioContext.ts
  - src/renderer/audio/Voice.ts
  - src/renderer/audio/VoiceManager.ts
  - src/renderer/audio/masterBus.ts
  - src/renderer/audio/envelopePresets.ts
  - src/renderer/audio/constants.ts
  - src/renderer/utils/envelopeMath.ts
  - vitest.config.ts
  - src/__tests__/envelopeMath.test.ts
  - src/__tests__/envelopePresets.test.ts
  - src/__tests__/Voice.test.ts
  - src/__tests__/VoiceManager.test.ts
autonomous: true
requirements:
  - AUDIO-01
  - AUDIO-02
  - AUDIO-03
  - AUDIO-04

must_haves:
  truths:
    - "8 persistent oscillators run simultaneously without clicks or pops"
    - "Waveform can be changed on all voices instantly (sine, square, sawtooth, triangle)"
    - "ADSR envelope shapes amplitude correctly on attack and release"
    - "4 envelope presets produce distinct audible characters"
    - "Envelope math utility produces correct curve points for canvas preview"
  artifacts:
    - path: "src/shared/types.ts"
      provides: "ADSRValues, OscillatorType, VoiceState, EnvelopeStage types"
      exports: ["ADSRValues", "VoiceState", "EnvelopeStage"]
    - path: "src/renderer/audio/Voice.ts"
      provides: "Single voice: OscillatorNode + GainNode + ADSR scheduling"
      exports: ["Voice"]
      min_lines: 60
    - path: "src/renderer/audio/VoiceManager.ts"
      provides: "Manages 8 Voice instances, global waveform, detune"
      exports: ["VoiceManager"]
      min_lines: 50
    - path: "src/renderer/audio/masterBus.ts"
      provides: "Master GainNode + DynamicsCompressorNode + AnalyserNode"
      exports: ["createMasterBus", "MasterBus"]
    - path: "src/renderer/audio/audioContext.ts"
      provides: "Singleton AudioContext with resume helper"
      exports: ["getAudioContext", "ensureAudioRunning"]
    - path: "src/renderer/audio/envelopePresets.ts"
      provides: "4 named ADSR presets"
      exports: ["ENVELOPE_PRESETS"]
    - path: "src/renderer/audio/constants.ts"
      provides: "Default pitches, detune, keyboard mapping"
      exports: ["DEFAULT_VOICE_PITCHES", "DEFAULT_VOICE_DETUNE", "DEFAULT_VOICE_KEYS"]
    - path: "src/renderer/utils/envelopeMath.ts"
      provides: "Pure function for ADSR curve point computation"
      exports: ["computeEnvelopeCurve"]
    - path: "vitest.config.ts"
      provides: "Vitest configuration"
  key_links:
    - from: "src/renderer/audio/Voice.ts"
      to: "AudioParam scheduling"
      via: "cancelScheduledValues + setValueAtTime + linearRampToValueAtTime + setTargetAtTime"
      pattern: "cancelScheduledValues.*setValueAtTime.*linearRamp"
    - from: "src/renderer/audio/VoiceManager.ts"
      to: "src/renderer/audio/Voice.ts"
      via: "creates and manages 8 Voice instances"
      pattern: "new Voice"
    - from: "src/renderer/audio/VoiceManager.ts"
      to: "src/renderer/audio/masterBus.ts"
      via: "voices connect to masterGain"
      pattern: "masterGain|masterBus"
    - from: "src/renderer/audio/Voice.ts"
      to: "src/shared/types.ts"
      via: "ADSRValues type import"
      pattern: "import.*ADSRValues"
---

<objective>
Build the complete audio engine with TDD: 8 persistent oscillator voices, per-voice ADSR envelope scheduling, global waveform selection, master bus with compressor/analyser, and envelope math utilities.

Purpose: This is the audio foundation that every subsequent phase builds on. Getting the oscillator architecture, anti-click AudioParam patterns, and envelope scheduling right here means no costly refactoring later. TDD ensures the scheduling logic is correct before wiring to UI.
Output: Working, tested audio engine module with zero React dependencies.
</objective>

<execution_context>
@/Users/aharbuz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aharbuz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-audio-foundation/01-RESEARCH.md
@.planning/phases/01-audio-foundation/01-01-SUMMARY.md
</context>

<feature>
  <name>Audio Engine Core with ADSR Envelopes</name>
  <files>
    src/shared/types.ts
    src/renderer/audio/audioContext.ts
    src/renderer/audio/Voice.ts
    src/renderer/audio/VoiceManager.ts
    src/renderer/audio/masterBus.ts
    src/renderer/audio/envelopePresets.ts
    src/renderer/audio/constants.ts
    src/renderer/utils/envelopeMath.ts
    vitest.config.ts
    src/__tests__/envelopeMath.test.ts
    src/__tests__/envelopePresets.test.ts
    src/__tests__/Voice.test.ts
    src/__tests__/VoiceManager.test.ts
  </files>
  <behavior>
    IMPORTANT: Use Context7 MCP to pull latest Web Audio API docs and Vitest docs BEFORE implementation.

    ## Types (src/shared/types.ts)
    - ADSRValues: { attack: number, decay: number, sustain: number, release: number } (all in seconds except sustain which is 0-1 gain)
    - EnvelopeStage: 'idle' | 'attack' | 'decay' | 'sustain' | 'release'
    - VoiceState: { isActive: boolean, stage: EnvelopeStage, frequency: number, detune: number }
    - WaveformType: 'sine' | 'square' | 'sawtooth' | 'triangle'
    - MasterBus: { masterGain: GainNode, compressor: DynamicsCompressorNode, analyser: AnalyserNode }

    ## Vitest Configuration (vitest.config.ts)
    - Configure Vitest with TypeScript support
    - Set environment to 'jsdom' (provides minimal Web Audio stubs)
    - Note: Full Web Audio testing requires mocking AudioContext -- test scheduling LOGIC, not actual audio output

    ## Envelope Math (src/renderer/utils/envelopeMath.ts)
    TDD candidate -- pure function with clear I/O:
    - computeEnvelopeCurve(adsr: ADSRValues, width: number, height: number, sampleCount?: number): { x: number, y: number }[]
    - Attack phase: linear from 0 to 1
    - Decay phase: exponential approach to sustain (matches setTargetAtTime with timeConstant = decay/3)
    - Sustain phase: flat at sustain level (display for 0.3s equivalent)
    - Release phase: exponential approach to 0 (matches setTargetAtTime with timeConstant = release/3)
    - Test cases:
      - computeEnvelopeCurve({ attack: 0, decay: 0, sustain: 1, release: 0 }, 100, 100) -> all points at y=0 (max amplitude) except release
      - computeEnvelopeCurve({ attack: 1, decay: 0, sustain: 1, release: 0 }, 100, 100) -> linear ramp up
      - First point always at (0, height) (zero amplitude)
      - Points are within canvas bounds (0 <= x <= width, 0 <= y <= height)
      - sampleCount matches returned array length

    ## Envelope Presets (src/renderer/audio/envelopePresets.ts)
    - 4 presets per user decision:
      - 'Pad (Drift)': attack: 0.8, decay: 1.2, sustain: 0.7, release: 2.0
      - 'Pluck (Snap)': attack: 0.005, decay: 0.3, sustain: 0.0, release: 0.1
      - 'Organ (Breathe)': attack: 0.01, decay: 0.05, sustain: 0.85, release: 0.01
      - 'Strings (Bloom)': attack: 0.4, decay: 0.5, sustain: 0.6, release: 1.5
    - Test: all presets have valid ranges (attack >= 0, sustain 0-1, etc.)

    ## Constants (src/renderer/audio/constants.ts)
    - DEFAULT_VOICE_PITCHES: C major scale C3-C4 [130.81, 146.83, 164.81, 174.61, 196.00, 220.00, 246.94, 261.63]
    - DEFAULT_VOICE_DETUNE: [-7, +5, -3, +8, -10, +4, -6, +11] (cents, range -12 to +12)
    - DEFAULT_VOICE_KEYS: ['a', 's', 'd', 'f', 'j', 'k', 'l', ';']
    - MASTER_GAIN: 0.15
    - COMPRESSOR_SETTINGS: { threshold: -24, knee: 12, ratio: 4, attack: 0.003, release: 0.25 }

    ## AudioContext Singleton (src/renderer/audio/audioContext.ts)
    - getAudioContext(): AudioContext -- lazy singleton with latencyHint: 'interactive'
    - ensureAudioRunning(): Promise<void> -- resumes if suspended
    - Expose context on window for Playwright testing: (window as any).__audioContext = ctx

    ## Master Bus (src/renderer/audio/masterBus.ts)
    - createMasterBus(ctx: AudioContext): MasterBus
    - Chain: masterGain(0.15) -> compressor(threshold:-24, knee:12, ratio:4, attack:0.003, release:0.25) -> analyser(fftSize:2048) -> destination
    - Export setMasterVolume(bus: MasterBus, volume: number) with anti-click pattern

    ## Voice Class (src/renderer/audio/Voice.ts)
    - Constructor: creates OscillatorNode + GainNode, connects to destination, starts oscillator, gain at 0
    - triggerAttack(): anti-click protocol (cancel -> anchor -> linear ramp to 1 -> setTargetAtTime to sustain)
    - triggerRelease(): anti-click protocol (cancel -> anchor -> setTargetAtTime to 0.0001 -> hard silence at release*1.67)
    - setWaveform(type): sets oscillator.type
    - setADSR(adsr): updates envelope values for next trigger
    - setFrequency(freq): sets oscillator frequency with setValueAtTime
    - getEnvelopeStage(): returns current EnvelopeStage based on timing
    - isActive getter
    - dispose(): stops and disconnects nodes
    - Test with mocked AudioContext: verify scheduling method calls and order

    ## VoiceManager (src/renderer/audio/VoiceManager.ts)
    - Constructor: creates AudioContext, MasterBus, 8 Voice instances with default pitches and detune
    - triggerAttack(voiceIndex: number): triggers specific voice
    - triggerRelease(voiceIndex: number): releases specific voice
    - setWaveform(type: WaveformType): updates all 8 voices
    - setADSR(adsr: ADSRValues): updates all 8 voices
    - setPreset(presetName: string): looks up preset and calls setADSR
    - getVoiceStates(): returns array of VoiceState for UI
    - getMasterBus(): returns MasterBus for analyser access
    - dispose(): cleans up all voices
    - Test: verify voice count, waveform propagation, ADSR propagation
  </behavior>
  <implementation>
    Follow TDD RED-GREEN-REFACTOR:

    RED: Write tests first for envelopeMath, envelopePresets, Voice (mocked AudioContext), VoiceManager (mocked). Tests must fail initially.

    GREEN: Implement each module to make tests pass. Start with types and constants (no tests needed -- pure data). Then envelopeMath (pure function). Then envelopePresets. Then audioContext singleton. Then masterBus. Then Voice. Then VoiceManager.

    REFACTOR: Clean up after green. Ensure all exports are typed. Ensure anti-click protocol is consistent across all gain changes.

    For Web Audio mocking in tests: Create a minimal mock that tracks method calls (cancelScheduledValues, setValueAtTime, linearRampToValueAtTime, setTargetAtTime) so tests verify the SCHEDULING PATTERN, not actual audio output.
  </implementation>
</feature>

<verification>
1. `npx vitest run` -- all tests pass
2. `npx tsc --noEmit` -- zero type errors
3. envelopeMath tests verify curve shape for all 4 presets
4. Voice tests verify anti-click scheduling pattern (cancel -> anchor -> ramp) for both attack and release
5. VoiceManager tests verify 8 voices created, waveform/ADSR propagation to all voices
</verification>

<success_criteria>
Complete audio engine module with:
- 8 persistent oscillators always running
- Anti-click AudioParam scheduling on every gain change
- 4 ADSR presets with correct values
- Envelope math utility producing correct curve points
- All tests passing
- Zero React dependencies in the audio module
</success_criteria>

<output>
After completion, create `.planning/phases/01-audio-foundation/01-02-SUMMARY.md`
</output>
