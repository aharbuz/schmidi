---
phase: 02-chord-engine-synth-mode
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/audio/ChordVoiceManager.ts
  - src/renderer/audio/constants.ts
  - src/__tests__/ChordVoiceManager.test.ts
autonomous: true
requirements:
  - CHORD-03

must_haves:
  truths:
    - "ChordVoiceManager allocates 3 voices per chord trigger and releases them as a group"
    - "Voice stealing reclaims the oldest chord's voices when the pool is exhausted"
    - "Multiple chords can sound simultaneously (polychordal support)"
    - "Released chords enter ADSR release phase (no instant cut)"
  artifacts:
    - path: "src/renderer/audio/ChordVoiceManager.ts"
      provides: "Voice pool manager with chord allocation, release, and voice stealing"
      exports: ["ChordVoiceManager"]
    - path: "src/__tests__/ChordVoiceManager.test.ts"
      provides: "Unit tests for voice allocation, release, and stealing"
  key_links:
    - from: "src/renderer/audio/ChordVoiceManager.ts"
      to: "src/renderer/audio/Voice.ts"
      via: "Creates and manages Voice instances from pool"
      pattern: "new Voice|voice\\.triggerAttack|voice\\.triggerRelease|voice\\.setFrequency"
    - from: "src/renderer/audio/ChordVoiceManager.ts"
      to: "src/renderer/audio/masterBus.ts"
      via: "Connects voice pool to master bus gain node"
      pattern: "createMasterBus|masterGain"
---

<objective>
Build the ChordVoiceManager: a voice pool that allocates groups of 3 voices per chord, supports polychordal playback, and implements oldest-first voice stealing.

Purpose: The Phase 1 VoiceManager maps 1 voice per button (8 fixed voices). Phase 2 chords need 3 voices each (triads) with dynamic allocation from a shared pool. This is the audio backbone for chord playback -- every chord trigger/release flows through this manager.

Output: `ChordVoiceManager` class with voice pool, chord allocation/release, voice stealing, and per-chord gain routing. Test suite covering allocation, polychordal overlap, and stealing.
</objective>

<execution_context>
@/Users/aharbuz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aharbuz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/renderer/audio/Voice.ts
@src/renderer/audio/masterBus.ts
@src/renderer/audio/constants.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChordVoiceManager with voice pool and chord allocation</name>
  <files>
    src/renderer/audio/ChordVoiceManager.ts
    src/renderer/audio/constants.ts
  </files>
  <action>
    1. Add constants to `src/renderer/audio/constants.ts`:
       - `CHORD_VOICE_POOL_SIZE = 24` (8 triads max)
       - `VOICES_PER_CHORD = 3` (triad)

    2. Create `src/renderer/audio/ChordVoiceManager.ts`:

       Interface `ChordAllocation`:
       - chordId: string (unique identifier for this chord trigger, format: "degree-{timestamp}")
       - voiceIndices: number[] (indices into the voice pool array)
       - triggerTime: number (audioContext.currentTime when triggered)
       - frequencies: number[] (Hz values assigned to voices)
       - degree: number (1-7, the chord degree -- stable ID for retuning on key/mode change)

       Class `ChordVoiceManager`:
       - Private fields: voices (Voice[]), allocations (Map<string, ChordAllocation>), ctx (AudioContext), masterBus (MasterBus reference, received in constructor -- do NOT create a new one, reuse Phase 1's)
       - Constructor(ctx: AudioContext, masterGain: GainNode, poolSize = CHORD_VOICE_POOL_SIZE):
         - Create `poolSize` Voice instances, each connected to the provided masterGain node
         - All voices start silent (gain 0), oscillator running (persistent pattern from Phase 1)
         - Store in this.voices array

       - `triggerChord(degree: number, frequencies: number[], waveform: WaveformType, adsr: ADSRValues): string`:
         - Generate chordId = `${degree}-${Date.now()}`
         - Call allocateVoices(VOICES_PER_CHORD) to get voice indices
         - For each allocated voice: setFrequency(freq), setWaveform(waveform), setADSR(adsr), triggerAttack()
         - Store allocation in Map with chordId as key
         - Return chordId

       - `releaseChord(chordId: string): void`:
         - Look up allocation by chordId
         - For each voice index: triggerRelease() (ADSR release, not instant silence)
         - Delete allocation from Map (voices will return to idle after release completes via Voice's setTimeout)

       - `releaseByDegree(degree: number): void`:
         - Find all allocations with matching degree, call releaseChord on each
         - This is the primary release method (user releases a chord key, all instances of that degree release)

       - `retuneActiveChords(chordDataArray: ChordData[]): void`:
         - For each active allocation: look up new chord data by degree, retune voices to new frequencies via setFrequency()
         - Used for live key/mode switching per user decision

       - `setWaveform(waveform: WaveformType): void`:
         - Set waveform on ALL voices in pool (not just active ones)

       - `setADSR(adsr: ADSRValues): void`:
         - Set ADSR on ALL voices in pool

       - `getAllocations(): Map<string, ChordAllocation>` (read-only access for retuning)

       - `getActiveVoiceCount(): number` (count of currently allocated voices)

       - Private `allocateVoices(count: number): number[]`:
         - Step 1: Find idle voices (where voice.isActive === false). If enough, return first `count` idle indices.
         - Step 2: Voice stealing -- find oldest allocation (lowest triggerTime). For the oldest allocation's voices: if any are in release phase, schedule hard silence (gain.setValueAtTime(0, now)) before retuning to avoid pitch chirp. Release the oldest chord, reclaim its voice indices.
         - Step 3: If still not enough after one steal, steal next oldest. Repeat until enough voices freed.
         - Return array of `count` voice indices.

       - `dispose(): void`:
         - Dispose all voices, clear allocations Map
  </action>
  <verify>
    `npx tsc --noEmit` passes. ChordVoiceManager exports correctly.
  </verify>
  <done>
    ChordVoiceManager creates a pool of 24 Voice instances, allocates 3 per chord trigger, releases via ADSR, steals from oldest when pool exhausted, supports retuning active chords for live key/mode switching.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for ChordVoiceManager</name>
  <files>src/__tests__/ChordVoiceManager.test.ts</files>
  <action>
    Create test file using Vitest with mocked AudioContext (same pattern as existing Phase 1 tests).

    Test cases:
    1. "creates voice pool of configured size" -- constructor creates 24 voices
    2. "triggerChord allocates 3 voices and returns chordId" -- trigger one chord, verify 3 voices active
    3. "releaseChord triggers ADSR release on allocated voices" -- trigger then release, verify voices enter release
    4. "releaseByDegree releases all allocations for a degree" -- trigger degree 1 twice (shouldn't happen normally but tests the path), releaseByDegree(1) releases both
    5. "supports polychordal playback" -- trigger 3 different chords simultaneously, verify 9 voices active
    6. "voice stealing reclaims oldest chord" -- fill pool (trigger 8 chords = 24 voices), trigger 9th chord, verify oldest chord released and 9th chord allocated
    7. "retuneActiveChords updates frequencies on active voices" -- trigger a chord, call retuneActiveChords with new frequencies, verify voices have new frequencies
    8. "setWaveform applies to all pool voices" -- verify all 24 voices get new waveform
    9. "dispose cleans up all voices" -- verify dispose called on all voices

    Use the same AudioContext mock pattern from existing tests (jsdom environment, mock AudioContext with createOscillator, createGain, createDynamicsCompressor, createAnalyser stubs).
  </action>
  <verify>
    `npx vitest run src/__tests__/ChordVoiceManager.test.ts` -- all tests pass.
  </verify>
  <done>
    9 test cases covering allocation, release, polychordal, voice stealing, retuning, and cleanup. All pass.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- all tests pass (existing Phase 1 + new ChordVoiceManager tests)
2. `npx tsc --noEmit` -- no type errors
3. ChordVoiceManager correctly reuses the Phase 1 Voice class without modification
</verification>

<success_criteria>
- Voice pool of 24 persistent oscillators created and connected to master bus
- 3 voices allocated per chord trigger, released as a group
- Multiple simultaneous chords supported (polychordal)
- Oldest-first voice stealing when pool exhausted
- Active chord retuning works for live key/mode switching
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-chord-engine-synth-mode/02-02-SUMMARY.md`
</output>
