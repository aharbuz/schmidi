---
phase: 05-instrument-personality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/audio/presets.ts
  - src/renderer/music/scaleFrequencies.ts
  - src/renderer/store/synthStore.ts
autonomous: true
requirements: [SLIDE-06, SLIDE-07, SLIDE-08, SLIDE-09]

must_haves:
  truths:
    - "Four preset definitions (Eerie, Bloom, Swarm, Custom) exist as functions mapping (intensity) to SlideConfig partials"
    - "Scale frequency table can be built from any key + mode combination across the C2-C6 pitch range"
    - "Magnetic snap quantizer produces gravitational pull toward nearest scale degree (not hard snap)"
    - "Staircase convergence curve builder generates stepped Float32Array through scale degrees between start and target"
    - "Store exposes activePreset, presetIntensity, idleMode, postArrivalMode, and snapScale state with actions"
    - "Changing any advanced config value auto-switches activePreset to 'custom' when it diverges from current preset"
  artifacts:
    - path: "src/renderer/audio/presets.ts"
      provides: "Preset definitions, PresetFn type, getPresetConfig, PRESET_NAMES"
      contains: "EERIE_PRESET"
    - path: "src/renderer/music/scaleFrequencies.ts"
      provides: "Scale frequency table builder, magnetic snap quantizer, staircase curve builder, binary search"
      exports: ["buildScaleFrequencyTable", "magneticSnap", "findNearestScaleFreq", "buildStaircaseCurve"]
    - path: "src/renderer/store/synthStore.ts"
      provides: "Extended store with preset state, idle mode, post-arrival mode, snap scale"
      contains: "applyPreset"
  key_links:
    - from: "src/renderer/audio/presets.ts"
      to: "src/renderer/audio/SlideTrack.ts"
      via: "imports SlideConfig type"
      pattern: "Partial<SlideConfig>"
    - from: "src/renderer/music/scaleFrequencies.ts"
      to: "tonal"
      via: "Scale.degrees + Note.freq for frequency generation"
      pattern: "Scale\\.degrees"
    - from: "src/renderer/store/synthStore.ts"
      to: "src/renderer/audio/presets.ts"
      via: "getPresetConfig in applyPreset action"
      pattern: "getPresetConfig"
---

<objective>
Create the preset system, scale frequency utilities, and extend the Zustand store with personality state.

Purpose: Establish the data layer that maps preset names + intensity to concrete SlideConfig values, build the scale pitch utilities needed for scale-snapped glissando, and extend the store so the engine and UI can read/write personality settings. This plan creates NO audio engine changes -- it builds the foundation that Plan 02 consumes.

Output: `presets.ts` (4 preset functions + intensity interpolation), `scaleFrequencies.ts` (scale table builder + magnetic snap + staircase curve), extended `synthStore.ts` (preset/personality state + actions).
</objective>

<execution_context>
@/Users/aharbuz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aharbuz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-instrument-personality/05-CONTEXT.md
@.planning/phases/05-instrument-personality/05-RESEARCH.md
@src/renderer/audio/SlideTrack.ts (SlideConfig interface + types + DEFAULT_SLIDE_CONFIG)
@src/renderer/store/synthStore.ts (current store to extend)
@src/renderer/music/chordEngine.ts (existing tonal usage patterns)
@src/renderer/music/musicTypes.ts (existing MODES constant)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create preset definitions and scale frequency utilities</name>
  <files>
    src/renderer/audio/presets.ts
    src/renderer/music/scaleFrequencies.ts
  </files>
  <action>
**presets.ts:**
Create a new file defining the preset system. Import `SlideConfig` from `SlideTrack.ts`.

Define types:
- `PresetName = 'eerie' | 'bloom' | 'swarm' | 'custom'`
- `PresetFn = (intensity: number) => Partial<SlideConfig>`
- `IdleMode = 'silent' | 'quiet-sliding' | 'ambient-drone'`
- `PostArrivalMode = 'hold' | 'cycle'`

Create `lerp(a, b, t)` helper for linear interpolation.

Define 4 preset functions (each returns a `Partial<SlideConfig>` based on intensity 0-1):

**EERIE_PRESET:** Slow and creepy -- horror-film pitch bending feel.
- `trackCorrelation: 'independent'`
- `movementSpeed: lerp(1.5, 0.4, intensity)` (slower at higher intensity)
- `movementSpeedVariation: lerp(0.3, 0.7, intensity)` (more erratic at higher intensity)
- `convergenceEasing: 'ease-out'`
- `convergenceDuration: lerp(1.5, 4.0, intensity)` (longer at higher intensity -- slow creepy convergence)
- `idleVolume: lerp(0.08, 0.02, intensity)` (quieter at higher intensity)
- `microMotion: false` (eerie = still/creepy when held)
- `microMotionDepth: 0`
- `autoCycle: false` (default hold mode)
- `holdDuration: Infinity`
- `pitchMovement: 'continuous'`
- `idleMovementMode: 'slow-drift'`
- `swellCurve: 'exponential'`
- `heldVolume: lerp(0.7, 0.9, intensity)`

**BLOOM_PRESET:** Lush sweeping convergence -- inward focus (cinematic feel, all tracks sweep toward center from spread positions).
- `trackCorrelation: 'loosely-correlated'`
- `movementSpeed: lerp(3.0, 1.5, intensity)` (medium speed, slower at higher intensity for lush feel)
- `movementSpeedVariation: lerp(0.1, 0.2, intensity)` (low variation -- coherent sweep)
- `convergenceEasing: 'ease-in-out'`
- `convergenceDuration: lerp(1.0, 2.5, intensity)`
- `idleVolume: lerp(0.1, 0.15, intensity)` (slightly louder idle)
- `microMotion: true` (warm vibrato when held)
- `microMotionDepth: lerp(5, 12, intensity)` (cents)
- `microMotionRate: lerp(4, 6, intensity)` (Hz -- warm vibrato speed)
- `autoCycle: true` (default cycle mode -- breathing convergence)
- `holdDuration: lerp(2.0, 1.0, intensity)` (cycle touch duration)
- `pitchMovement: 'continuous'`
- `idleMovementMode: 'slow-drift'`
- `swellCurve: 'linear'`
- `heldVolume: lerp(0.8, 1.0, intensity)`

**SWARM_PRESET:** Chaotic energy -- erratic behavior, more tracks.
- `trackCorrelation: 'independent'`
- `trackCount: intensity > 0.5 ? 4 : 3` (more tracks at higher intensity)
- `movementSpeed: lerp(4.0, 8.0, intensity)` (fast, faster at higher intensity)
- `movementSpeedVariation: lerp(0.5, 0.9, intensity)` (high variation -- erratic)
- `convergenceEasing: 'linear'`
- `convergenceDuration: lerp(0.8, 0.4, intensity)` (fast convergence)
- `idleVolume: lerp(0.06, 0.12, intensity)`
- `microMotion: intensity > 0.3` (jittery micro-motion when held)
- `microMotionDepth: lerp(8, 25, intensity)` (wide jitter)
- `microMotionRate: lerp(6, 12, intensity)` (fast jitter)
- `autoCycle: true` (default cycle)
- `holdDuration: lerp(1.0, 0.3, intensity)` (quick cycle)
- `pitchMovement: 'continuous'`
- `idleMovementMode: 'random-walk'`
- `swellCurve: 'linear'`
- `heldVolume: lerp(0.7, 0.85, intensity)`

**CUSTOM_PRESET:** Identity function -- returns empty partial (no overrides). Selecting "custom" means "use whatever values the advanced controls have set."

Export `PRESET_NAMES: PresetName[] = ['eerie', 'bloom', 'swarm', 'custom']`
Export `PRESET_MAP: Record<PresetName, PresetFn>` mapping name to function.
Export `getPresetConfig(name: PresetName, intensity: number): Partial<SlideConfig>` that calls the appropriate preset function.
Export `getPresetIdleMode(name: PresetName): IdleMode` -- eerie: 'quiet-sliding', bloom: 'quiet-sliding', swarm: 'quiet-sliding', custom: 'quiet-sliding'.
Export `getPresetPostArrivalMode(name: PresetName): PostArrivalMode` -- eerie: 'hold', bloom: 'cycle', swarm: 'cycle', custom: 'hold'.

**scaleFrequencies.ts:**
Create a new file in `src/renderer/music/` for scale pitch utilities. Import `Scale, Note` from `tonal`.

`buildScaleFrequencyTable(key: string, mode: string, lowFreq?: number, highFreq?: number): number[]`
- Default range: 65.41 (C2) to 1046.5 (C6)
- Use `Scale.degrees(\`${key}0 ${mode}\`)` to get a degree function
- Get scale size from `Scale.get(\`${key} ${mode}\`).notes.length`
- Iterate degrees 1 through scaleSize * 8
- For each degree: get note name, get freq via `Note.freq()`, skip if null or below lowFreq, break if above highFreq
- Return sorted ascending array of frequencies

`findNearestScaleFreq(freq: number, scaleFreqs: number[]): number`
- Binary search on sorted scaleFreqs array
- Compare distances in log-frequency space (semitone-proportional)
- Return nearest frequency

`magneticSnap(freeFreq: number, scaleFreqs: number[], snapStrength?: number): number`
- Default snapStrength: 0.8
- Find nearest scale degree via findNearestScaleFreq
- Compute distance in semitones: `Math.abs(Math.log2(freeFreq / nearest) * 12)`
- Gravitational pull: `1 / (1 + distSemitones * distSemitones)` scaled by snapStrength
- Interpolate in log-frequency space between freeFreq and nearest
- Return the magnetically-snapped frequency

`buildStaircaseCurve(startFreq: number, targetFreq: number, scaleFreqs: number[], curveLength?: number): Float32Array`
- Default curveLength: 512
- Filter scaleFreqs to those between startFreq and targetFreq
- Sort ascending or descending based on direction
- Ensure start and target are included as first/last steps
- Allocate Float32Array(curveLength)
- Distribute samples evenly across steps (each step gets `floor(curveLength / steps.length)` samples)
- Last step fills remaining samples
- Return the curve (compatible with setValueCurveAtTime)
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- both new files must compile with no type errors. Verify the files exist and export the expected symbols.
  </verify>
  <done>
presets.ts exports PresetName, PresetFn, IdleMode, PostArrivalMode, PRESET_NAMES, PRESET_MAP, getPresetConfig, getPresetIdleMode, getPresetPostArrivalMode. scaleFrequencies.ts exports buildScaleFrequencyTable, findNearestScaleFreq, magneticSnap, buildStaircaseCurve. Both files compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend synthStore with preset and personality state</name>
  <files>
    src/renderer/store/synthStore.ts
  </files>
  <action>
Extend the existing Zustand store in `synthStore.ts` with personality state and actions. Import types from `presets.ts`.

**New state fields** (add to existing store state):
- `activePreset: PresetName` (default: `'bloom'`)
- `presetIntensity: number` (default: `0.5`)
- `idleMode: IdleMode` (default: `'quiet-sliding'`)
- `postArrivalMode: PostArrivalMode` (default: `'hold'`)
- `snapScaleKey: string | null` (default: `null` -- null means "use active key")
- `snapScaleMode: string | null` (default: `null` -- null means "use active mode")

**New actions:**

`applyPreset: (name: PresetName) => void`
- Call `getPresetConfig(name, get().presetIntensity)` to get SlideConfig partial
- Call `getPresetIdleMode(name)` for idle mode default
- Call `getPresetPostArrivalMode(name)` for post-arrival mode default
- Set `activePreset: name`, `idleMode`, `postArrivalMode` in store
- If name === 'custom', skip applying config to engine (custom uses current values)
- Otherwise: call `slideEngineRef?.updateConfig(presetConfig)` and update `slideConfig` state
- Also update `slideConfig` with the new values for UI consistency

`setPresetIntensity: (intensity: number) => void`
- Set `presetIntensity: intensity` in store
- If `activePreset !== 'custom'`, recompute preset config and apply to engine
- Same pattern as applyPreset but doesn't change the preset name

`setIdleMode: (mode: IdleMode) => void`
- Set `idleMode: mode` in store
- Check if this diverges from current preset's default idle mode -- if so, set `activePreset: 'custom'`
- Apply idle mode to engine (SlideEngine will handle mode switching in Plan 02)

`setPostArrivalMode: (mode: PostArrivalMode) => void`
- Set `postArrivalMode: mode` in store
- Map to engine config: 'hold' -> `{ autoCycle: false, holdDuration: Infinity }`, 'cycle' -> `{ autoCycle: true, holdDuration: get().slideConfig.holdDuration }`
- Apply via `slideEngineRef?.updateConfig(...)`
- Check if diverges from preset default -- if so, set `activePreset: 'custom'`

`setSnapScale: (key: string | null, mode: string | null) => void`
- Set `snapScaleKey` and `snapScaleMode` in store
- This triggers scale frequency table rebuild in Plan 02 (engine integration)

**Modify existing `updateSlideConfig` action:**
- After applying the config change, check if `activePreset !== 'custom'`
- If so, compute `getPresetConfig(activePreset, presetIntensity)` and check if the changed keys diverge
- If diverged, set `activePreset: 'custom'` (auto-switch to custom per CONTEXT.md decision)
  </action>
  <verify>
Run `npx tsc --noEmit` -- store must compile cleanly with new state fields and actions. Check that all new exports are accessible.
  </verify>
  <done>
synthStore exports all new state fields (activePreset, presetIntensity, idleMode, postArrivalMode, snapScaleKey, snapScaleMode) and actions (applyPreset, setPresetIntensity, setIdleMode, setPostArrivalMode, setSnapScale). The updateSlideConfig action detects preset divergence and auto-switches to custom. All compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx eslint src/renderer/audio/presets.ts src/renderer/music/scaleFrequencies.ts src/renderer/store/synthStore.ts --max-warnings=0` passes
3. All new type exports are importable from their modules
4. getPresetConfig returns different values for different preset names and different intensity values
5. buildScaleFrequencyTable returns a sorted ascending array with reasonable frequency counts (28+ for 4 octaves of diatonic scale)
</verification>

<success_criteria>
- presets.ts contains 4 preset definitions with intensity-scaled parameter values
- scaleFrequencies.ts contains scale table builder, magnetic snap, staircase curve, binary search
- synthStore.ts extended with preset/personality state and 5 new actions
- Custom preset auto-activation logic works when advanced controls diverge from current preset
- All files compile and lint cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-instrument-personality/05-01-SUMMARY.md`
</output>
