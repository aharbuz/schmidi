---
phase: 04-visualization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/audio/SlideTrack.ts
  - src/renderer/components/visualization/WaveformBuffer.ts
  - src/renderer/components/visualization/WaveformView.tsx
autonomous: true
requirements: [VIZ-02]

must_haves:
  truths:
    - "Each slide track has an individual AnalyserNode tapping its raw oscillator output"
    - "Waveform canvas shows per-track colored oscilloscope traces"
    - "Traces represent ~10 seconds of time-domain data showing the full convergence arc"
    - "Track line brightness and thickness increase as proximity increases"
    - "As tracks converge, waveforms visually align (same frequency = same wave shape)"
    - "Convergence payoff: waveforms briefly flash bright and thicken when tracks arrive at target"
    - "Abstract presentation -- no pitch labels or note names on axes"
  artifacts:
    - path: "src/renderer/audio/SlideTrack.ts"
      provides: "Per-track AnalyserNode (osc -> analyser -> swellGain chain)"
      contains: "this.analyser"
    - path: "src/renderer/components/visualization/WaveformBuffer.ts"
      provides: "Rolling circular buffer for ~10s of per-track waveform data"
      exports: ["WaveformBuffer"]
    - path: "src/renderer/components/visualization/WaveformView.tsx"
      provides: "Waveform trace canvas component"
      exports: ["WaveformView"]
  key_links:
    - from: "src/renderer/audio/SlideTrack.ts"
      to: "AnalyserNode"
      via: "osc.connect(analyser); analyser.connect(swellGain)"
      pattern: "this\\.analyser"
    - from: "src/renderer/components/visualization/WaveformView.tsx"
      to: "SlideEngine.getTracks()"
      via: "module-level ref access for analyser data"
      pattern: "getSlideEngine|analyser"
    - from: "src/renderer/components/visualization/WaveformView.tsx"
      to: "WaveformBuffer"
      via: "per-track buffer instances in useRef"
      pattern: "WaveformBuffer"
---

<objective>
Create the waveform trace view -- per-track colored oscilloscope traces showing ~10 seconds of convergence history. Requires inserting AnalyserNodes into SlideTrack audio graph and building a rolling buffer system.

Purpose: VIZ-02 (waveform trace view with colored waveform traces morphing and aligning as pitches converge). The waveform view is the analytical counterpart to the radial view -- it shows the wave shapes converging over time.
Output: Modified SlideTrack.ts with per-track AnalyserNodes, WaveformBuffer.ts circular buffer class, WaveformView.tsx canvas component.
</objective>

<execution_context>
@/Users/aharbuz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aharbuz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-visualization/04-CONTEXT.md
@.planning/phases/04-visualization/04-RESEARCH.md
@src/renderer/audio/SlideTrack.ts
@src/renderer/components/Oscilloscope.tsx
@src/renderer/hooks/useAnimationLoop.ts
@src/renderer/store/synthStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Per-track AnalyserNodes in SlideTrack + WaveformBuffer class</name>
  <files>
    src/renderer/audio/SlideTrack.ts
    src/renderer/components/visualization/WaveformBuffer.ts
  </files>
  <action>
**SlideTrack.ts** -- Insert an AnalyserNode into each SlideTrack's audio graph:

Current chain: `osc -> swellGain -> trackGain -> masterGain`
New chain: `osc -> analyser -> swellGain -> trackGain -> masterGain`

The analyser taps the raw oscillator output BEFORE gain processing, giving a clean per-track waveform regardless of volume level.

Modifications:
- Add `analyser: AnalyserNode` property to the SlideTrack class
- In constructor, after creating `this.osc`:
  ```
  this.analyser = ctx.createAnalyser();
  this.analyser.fftSize = 256; // 128 samples, enough for visual
  this.analyser.smoothingTimeConstant = 0.3; // slight smoothing for visual coherence
  ```
- Change the connection: instead of `this.osc.connect(this.swellGain)`, do:
  ```
  this.osc.connect(this.analyser);
  this.analyser.connect(this.swellGain);
  ```
- In `dispose()` method, add `this.analyser.disconnect()` before the existing disconnections
- Export a `getAnalyser(): AnalyserNode` method on SlideTrack so WaveformView can read from it

Also need to expose tracks from SlideEngine for analyser access:
- Check if SlideEngine already has a `getTracks()` method that returns the SlideTrack instances. If not, add `getTracks(): SlideTrack[]` that returns `this.tracks` (the internal array). This is needed so the waveform view can call `track.getAnalyser()`.

**WaveformBuffer.ts** -- Circular buffer for ~10s of waveform snapshots per track:
- `WAVEFORM_HISTORY_FRAMES = 600` (60fps x 10s)
- `SAMPLES_PER_FRAME = 128` (matches fftSize/2)
- Class `WaveformBuffer`:
  - Constructor: pre-allocates `Float32Array(frames * samplesPerFrame)` and a reusable `Uint8Array(samplesPerFrame)` for `getByteTimeDomainData` reads (avoiding GC pressure per Pitfall 4)
  - `push(analyser: AnalyserNode): void` -- reads `getByteTimeDomainData` into reusable buffer, normalizes to -1..1, writes into circular buffer at writeHead, advances writeHead
  - `getOrderedData(): Float32Array` -- returns data in chronological order (oldest to newest). Returns a reference to an internal pre-allocated result array (reused, not new allocation each call)
  - `reset(): void` -- zeros the buffer and resets writeHead (for when track count changes)

Key performance decisions:
- Pre-allocate ALL typed arrays in constructor (no `new` in the render loop)
- `getOrderedData` reuses a pre-allocated result array (same instance each call)
- The Uint8Array for `getByteTimeDomainData` is also pre-allocated once
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Verify SlideTrack audio graph change is correct: `osc -> analyser -> swellGain -> trackGain -> masterGain`. Verify WaveformBuffer compiles and exports correctly.
  </verify>
  <done>
Each SlideTrack has an AnalyserNode between osc and swellGain. SlideEngine exposes tracks for analyser access. WaveformBuffer implements zero-allocation circular buffer for ~10s of per-track waveform data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Waveform trace canvas component</name>
  <files>
    src/renderer/components/visualization/WaveformView.tsx
  </files>
  <action>
Create `WaveformView.tsx` -- waveform trace canvas component showing per-track oscilloscope lines with ~10s history.

**Canvas setup:**
- Import and use `useCanvasSetup` from Plan 01 (it will exist when this runs since both are Wave 1, but if Plan 01 hasn't been executed yet, create a minimal inline version: `const dpr = devicePixelRatio; canvas.width = rect.width * dpr; ...` -- the hook can be adopted when Plan 03 integrates). Actually, since both plans are Wave 1 (parallel), this plan should NOT depend on Plan 01's hook. Create the HiDPI setup inline in this component or duplicate the small setup logic. The Plan 03 integration will normalize.
- Container div: `w-full h-full`
- Background: same dark void as radial view (`#08080c` center, `#0f0f18` edges) -- paint as filled rect each frame

**WaveformBuffer management (useRef, not state):**
- Store per-track `WaveformBuffer` instances in a `useRef<WaveformBuffer[]>`. Create/reset when track count changes (compare with previous count via ref).
- Each frame in the rAF loop:
  1. Get SlideEngine ref via `getSlideEngine()`
  2. Get tracks via `engine.getTracks()`
  3. For each track, call `buffer.push(track.getAnalyser())` to capture the current frame
  4. Get `slideTrackStates` from Zustand for proximity/state info

**Trace rendering (per-track):**
- Import `TRACK_HUES` and `computeTrackViz` from `vizColors.ts` (this file exists independently, no dependency on RadialView). Again, if Plan 01 hasn't run yet, inline the TRACK_HUES array and proximity math. Plan 03 normalizes.
- Stack tracks vertically with even spacing: `yOffset = (canvasHeight / (trackCount + 1)) * (trackIndex + 1)`
- For each track:
  - Get ordered waveform data from `buffer.getOrderedData()`
  - Color: `hsla(hue, saturation%, brightness%, alpha)` using computeTrackViz values
  - Line width: `1 + proximity` (thicker when converged)
  - Amplitude scaling: `30 + proximity * 20` pixels (larger amplitude when close)
  - Draw as a continuous path (`beginPath`, `moveTo`, `lineTo` loop, `stroke`)
  - The x-axis spans the full canvas width (600 frames mapped to width)

**Convergence payoff in waveform view:**
- When a track transitions from `converging` to `held` (detect via previous-state ref, same pattern as RadialView bloom detection):
  - Flash: briefly set line brightness to 95%, alpha to 1.0, lineWidth to 3 for ~300ms
  - Fade back to normal held-state values over 200ms
- Track flash state per track in a useRef array: `{ flashing: boolean, flashPhase: number }`

**Abstract presentation:** Per user decision -- no axis labels, no pitch text, no grid lines. Just the colored waveform traces on dark background.

**Subtle visual separator lines:**
- Faint horizontal center lines at each track's yOffset (`strokeStyle = 'rgba(255,255,255,0.03)'`, lineWidth 1) -- gives a sense of baseline without being a "label"

**Performance notes:**
- WaveformBuffers are in useRef, NOT Zustand (per research anti-pattern warning)
- The reusable Uint8Array in WaveformBuffer prevents GC pressure
- Only reads from AnalyserNode when the waveform view is actually active (component mounted)
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Verify WaveformView reads from per-track AnalyserNodes (not the master bus). Verify WaveformBuffer instances are in useRef, not reactive state.
  </verify>
  <done>
WaveformView renders per-track colored oscilloscope traces spanning ~10 seconds. Traces brighten and thicken as proximity increases. Flash payoff at convergence moment. Abstract presentation with no labels. Zero-allocation buffer pattern prevents GC stalls.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- SlideTrack audio chain: `osc -> analyser -> swellGain -> trackGain -> masterGain` (verify by reading constructor)
- SlideTrack.dispose() disconnects analyser
- WaveformBuffer: pre-allocated typed arrays, no `new` in push/getOrderedData
- WaveformView: reads per-track analysers (not master bus), buffers in useRef
</verification>

<success_criteria>
Per-track AnalyserNodes provide individual waveform data. WaveformBuffer captures ~10s history per track with zero GC pressure. WaveformView canvas renders colored traces that brighten on proximity and flash at convergence. All compiles clean.
</success_criteria>

<output>
After completion, create `.planning/phases/04-visualization/04-02-SUMMARY.md`
</output>
