---
phase: 04-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/components/visualization/vizColors.ts
  - src/renderer/hooks/useCanvasSetup.ts
  - src/renderer/components/visualization/RadialView.tsx
  - src/renderer/store/synthStore.ts
autonomous: true
requirements: [VIZ-01, VIZ-03]

must_haves:
  truths:
    - "Radial canvas renders orb elements for each slide track at 60fps"
    - "Orbs move toward canvas center as track proximity increases (0=outer, 1=center)"
    - "Orb brightness and size scale with proximity (warm/bright on approach, cool/dim on drift)"
    - "When tracks converge on a chord, overlapping orbs produce a bloom effect via additive blending"
    - "Bloom flashes at the moment of arrival then fades to steady glow while chord is held"
    - "Bloom color blends the hues of the converging tracks"
    - "Canvas is sharp on Retina displays (HiDPI scaling handled)"
  artifacts:
    - path: "src/renderer/components/visualization/vizColors.ts"
      provides: "Track hue palette + proximity-to-visual mapping"
      exports: ["TRACK_HUES", "computeTrackViz"]
    - path: "src/renderer/hooks/useCanvasSetup.ts"
      provides: "Canvas HiDPI setup + ResizeObserver"
      exports: ["useCanvasSetup"]
    - path: "src/renderer/components/visualization/RadialView.tsx"
      provides: "Radial convergence canvas component"
      exports: ["RadialView"]
    - path: "src/renderer/store/synthStore.ts"
      provides: "vizMode and fullViz state + actions"
      contains: "vizMode"
  key_links:
    - from: "src/renderer/components/visualization/RadialView.tsx"
      to: "synthStore.slideTrackStates"
      via: "useSynthStore selector"
      pattern: "useSynthStore.*slideTrackStates"
    - from: "src/renderer/components/visualization/RadialView.tsx"
      to: "src/renderer/components/visualization/vizColors.ts"
      via: "import computeTrackViz"
      pattern: "import.*computeTrackViz"
    - from: "src/renderer/components/visualization/RadialView.tsx"
      to: "src/renderer/hooks/useCanvasSetup.ts"
      via: "import useCanvasSetup"
      pattern: "import.*useCanvasSetup"
---

<objective>
Create the radial convergence view -- the primary visualization showing track orbs spiraling toward center as slide tracks approach chord target notes. Includes the shared visualization color system, HiDPI canvas setup hook, and Zustand state for view mode switching.

Purpose: VIZ-01 (radial convergence view at 60fps) and partial VIZ-03 (store state for view mode). This is the visual heart of the instrument -- orbs converging and blooming when chords land.
Output: RadialView.tsx canvas component, vizColors.ts color utilities, useCanvasSetup.ts hook, synthStore vizMode/fullViz state.
</objective>

<execution_context>
@/Users/aharbuz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aharbuz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-visualization/04-CONTEXT.md
@.planning/phases/04-visualization/04-RESEARCH.md
@src/renderer/store/synthStore.ts
@src/renderer/hooks/useAnimationLoop.ts
@src/renderer/audio/SlideTrack.ts
@src/renderer/components/Oscilloscope.tsx
@src/renderer/index.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Visualization color system + canvas setup hook + store state</name>
  <files>
    src/renderer/components/visualization/vizColors.ts
    src/renderer/hooks/useCanvasSetup.ts
    src/renderer/store/synthStore.ts
  </files>
  <action>
**vizColors.ts** -- Create the shared color system used by both radial and waveform views:
- Export `TRACK_HUES` array: `[185, 300, 45, 120, 260, 30, 330, 160]` (cyan, magenta, gold, green, purple, orange, pink, teal) -- per-track distinct hues
- Export `TrackVizData` interface: `{ hue, proximity, brightness, saturation, size, glowRadius, alpha }`
- Export `computeTrackViz(trackState: SlideTrackState, trackIndex: number): TrackVizData` -- maps proximity 0-1 to visual intensity:
  - brightness: `30 + proximity * 60` (30% to 90%)
  - saturation: `60 + proximity * 40` (60% to 100%)
  - size: `20 * (0.5 + proximity * 0.5)` base orb size
  - glowRadius: `40 * proximity`
  - alpha: `0.3 + proximity * 0.7`
- Export `blendHues(hues: number[], weights?: number[]): number` -- weighted average for convergence bloom color blending (wrapping around 360)

**useCanvasSetup.ts** -- Reusable hook for HiDPI canvas lifecycle:
- Takes a containerRef (RefObject<HTMLDivElement>) and returns `{ canvasRef, ctxRef, dimensions }` where dimensions = `{ width, height }` in CSS pixels
- On mount and on container resize (via ResizeObserver), scale canvas buffer by `devicePixelRatio`, set CSS size, call `ctx.scale(dpr, dpr)`
- Use `getContext('2d', { alpha: false })` for performance (opaque background)
- Clean up ResizeObserver on unmount

**synthStore.ts** -- Add visualization state (small addition to existing store):
- Add to SynthState interface: `vizMode: 'radial' | 'waveform'` (default `'radial'`), `fullViz: boolean` (default `false`)
- Add actions: `setVizMode: (mode: 'radial' | 'waveform') => void`, `toggleFullViz: () => void`
- Implementation is trivial set calls
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- no type errors. Verify vizColors.ts exports are importable and synthStore compiles with new state.
  </verify>
  <done>
vizColors.ts exports TRACK_HUES, computeTrackViz, blendHues. useCanvasSetup.ts exports hook. synthStore has vizMode/fullViz state and actions. All compile clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Radial convergence canvas with orbs, proximity positioning, and bloom</name>
  <files>
    src/renderer/components/visualization/RadialView.tsx
  </files>
  <action>
Create `RadialView.tsx` -- the radial convergence canvas component. This reads `slideTrackStates` from Zustand and paints orbs on a Canvas 2D surface every frame via its own rAF loop.

**Canvas setup:**
- Use `useCanvasSetup` hook for HiDPI-aware canvas in a container div
- The container div should be `w-full h-full` (fills whatever parent gives it)
- Background: subtle radial gradient void -- near-black center (`#08080c`) fading to slightly lighter edges (`#0f0f18`). Paint this as the first thing each frame (no `clearRect` needed since we paint the whole canvas)

**Per-track orb rendering (every frame):**
- Read `slideTrackStates` from `useSynthStore` (the animation loop already pushes these at 60fps)
- For each track, call `computeTrackViz` to get visual properties
- Position: map proximity to radial distance from center. `distance = maxRadius * (1 - proximity)` where `maxRadius = Math.min(w, h) * 0.4`. Angle: `(trackIndex / totalTracks) * 2 * PI` + subtle organic wobble from `Math.sin(currentFreq * 0.01) * 0.3`
- Draw orb using a pre-rendered glow sprite pattern:
  - Create sprites ONCE (use useRef to cache). For each unique hue, create an offscreen canvas with a radial gradient (center bright HSLA, fading to transparent)
  - Re-create sprites only when track count changes (hue assignment changes)
  - Each frame: draw the sprite at the computed position using `drawImage`, scaling by `size` from TrackVizData

**Glow halo + additive blending:**
- After drawing all orb bodies with `source-over`, switch to `globalCompositeOperation = 'lighter'`
- Draw a larger, more transparent glow sprite for each orb (the `glowRadius` from TrackVizData)
- Reset to `source-over` immediately after

**Convergence bloom effect:**
- Track each track's previous state (useRef). When a track transitions from `converging` to `held`, trigger a bloom at the canvas center
- Bloom state: `{ active: boolean, phase: number, blendedHue: number }`. Phase goes from 0 to 1 over ~400ms (increment by `deltaTime / 400`). Flash then fade per user decision.
- Bloom rendering: create a radial gradient at canvas center using `blendHues()` from the converging tracks. Large radius expanding outward (`radius = maxRadius * 0.6 * (0.5 + phase * 0.5)`), alpha fading (`1 - phase`). Draw with `globalCompositeOperation: 'lighter'`. Note: this gradient is created per-frame but ONLY during the brief bloom (acceptable per research).
- When held, show a subtle steady glow at center (smaller radius, lower alpha ~0.15) using the blended hue

**Motion trail (subtle):**
- Instead of full `clearRect`, paint the background gradient with very slight transparency would add complexity. Simpler: just paint opaque background each frame. The motion feel comes from the orb glow halos.

**No reference geometry:** Per user decision -- no pitch rings, no target markers, no labels. Just orbs, glow, and bloom.

**Performance notes:**
- Pre-allocate all typed arrays and sprites
- Do NOT store per-frame data in Zustand (read slideTrackStates which is already there)
- The rAF loop for canvas drawing is separate from useAnimationLoop (which polls engine state). This is fine because the canvas loop just reads from Zustand store (cheap read), and the rendering is the expensive part.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. The component can be temporarily rendered in App.tsx center section (replace SlideModeUI temporarily) to visually verify orbs render. Full integration happens in Plan 03.
  </verify>
  <done>
RadialView renders a canvas with per-track glowing orbs positioned radially by proximity. Additive blending creates natural bloom when orbs overlap at center. Convergence bloom flashes and fades. Canvas is HiDPI-aware. No reference geometry -- clean abstract visualization.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- vizColors.ts: `computeTrackViz({ state: 'converging', currentFreq: 440, targetFreq: 440, proximity: 0.8 }, 0)` returns object with brightness ~78, alpha ~0.86
- RadialView.tsx: renders a canvas element, reads slideTrackStates, uses pre-rendered sprites (no createRadialGradient every frame for orbs)
- synthStore: `useSynthStore.getState().vizMode` returns `'radial'`, `toggleFullViz` flips `fullViz`
</verification>

<success_criteria>
Radial convergence canvas component exists and compiles. Color system shared with future waveform view. Store has vizMode/fullViz state ready for layout integration. Orbs glow and bloom at convergence. 60fps target with pre-rendered sprites.
</success_criteria>

<output>
After completion, create `.planning/phases/04-visualization/04-01-SUMMARY.md`
</output>
